import { inRange, decoderError, encoderError, floor, isASCIICodePoint, isASCIIByte,
  end_of_stream, finished } from '../utils'
import index, { indexCodePointFor, indexShiftJISPointerFor } from '../indexes'


// 13.3 Shift_JIS

// 13.3.1 Shift_JIS decoder
/**
 * @constructor
 * @implements {Decoder}
 * @param {{fatal: boolean}} options
 */
export class ShiftJISDecoder {
  constructor(options) {
    const { fatal } = options
    this.fatal = fatal
    // Shift_JIS's decoder has an associated Shift_JIS lead (initially
    // 0x00).
    this.Shift_JIS_lead = 0x00
  }
  /**
   * @param {Stream} stream The stream of bytes being decoded.
   * @param {number} bite The next byte read from the stream.
   */
  handler(stream, bite) {
  // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,
  // set Shift_JIS lead to 0x00 and return error.
    if (bite === end_of_stream && this.Shift_JIS_lead !== 0x00) {
      this.Shift_JIS_lead = 0x00
      return decoderError(this.fatal)
    }

    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,
    // return finished.
    if (bite === end_of_stream && this.Shift_JIS_lead === 0x00)
      return finished

    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,
    // let pointer be null, set Shift_JIS lead to 0x00, and then run
    // these substeps:
    if (this.Shift_JIS_lead !== 0x00) {
      var lead = this.Shift_JIS_lead
      var pointer = null
      this.Shift_JIS_lead = 0x00

      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41
      // otherwise.
      var offset = (bite < 0x7F) ? 0x40 : 0x41

      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and
      // 0xC1 otherwise.
      var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1

      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×
      // 188 + byte − offset.
      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))
        pointer = (lead - 